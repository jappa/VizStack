#!/usr/bin/env python

# VizStack - A Framework to manage visualization resources

# Copyright (C) 2009-2010 Hewlett-Packard
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


"""
viz_vgl

VizStack support for using VirtualGL with VGL Image Transport.

So the user gets his desktop directly.
"""
import vsapi
from vsapi import ResourceAccess, Screen, GPU, Server, Keyboard, Mouse, VizResource, VizError
from pprint import pprint
from optparse import OptionParser, OptionGroup
import sys
import re
import time
import string
import socket
import os
import subprocess
import socket
import copy
import pwd

parser = OptionParser(
usage= "usage: viz_vgl [options] [application args]",
description=
"""Runs an application using VirtualGL, using the VGL Image Transport if needed.  In this mode, the GUI of the application runs on the local X server while the OpenGL rendering happens on an allocated GPU.

You must execute this script either inside an X desktop session, or inside an SSH session with X11 forwarding enabled. This script will automatically pick up a GPU for you to use.  However, you may also choose a GPU by passing one/more of the options described below.

If the allocated GPU is on a different node, then this script uses VGL Image Transport with X11 Forwarding, over an SSH connection. If you haven't setup passwordless SSH, then you'll be prompted for a password.  The X11 traffic generated by the application passes via SSH, and is always encrypted.

The VirtualGL client program is started if the --x11-draw option is not specified. You may point the script to a running VirtualGL client by setting up the environment variables VGL_CLIENT and VGL_PORT to point to it.
""")
group = OptionGroup(parser, "Resource Allocation Options")
group.add_option("-x", "--exclusive", dest="exclusive", action="store_true", default=False, help="Allocate a complete GPU for your use. By default, this script allocates a shared GPU for you. Use this flag to run applications that are expected to use a large percentage of GPU capabilities.")
group.add_option("-s", "--stereo", dest="use_stereo", action="store_true", default=False, help="Use this to run an application in stereo mode.  You may run an application in stereo, provided that the local X server is setup to enable Quad Buffered Stereo. Stereo implies exclusive access.")
group.add_option("--gpu-type", dest="gpu_type", help="Allocate a specific type of GPU for this remote session. Note that the GPU type will have spaces in it, so you will need to quote the string. Examples are \"Quadro FX 5800\", \"Quadro FX 1500\", etc. Use the --show-gpu-types option to print out a list of GPU types that may be potentially available.")
group.add_option("-N", "--full-node", dest="full_node", default=False, action='store_true', help='Allocate all resources on a node(in exclusive mode) for use by the desktop. Use this if you want to use applications that attempt to use ALL gpus found in the system, and there is no way to tell the application which GPUs to use.')
group.add_option("-a", "--allocate-from", dest="allocate_from", action="append", help="Allocate a GPU on this hostname. If you use this option multiple times, then a single GPU from one of the specified hosts will be used. Note that the allocation is independent of the order in which the hostnames are specified on the command line. The behaviour of this option changes when one of --specific-gpus or --specific-nodes is used, as noted below.")
parser.add_option_group(group)
group = OptionGroup(parser, "Additional Resource Allocation Options")
group.add_option("--specific-gpus", dest="specific_gpus", action="store_true", default=False, help="Use this if you want to allocate specific GPUs. Use the -a option one or more times to specify the GPUs you need. Note that only the first GPU will be used to power the VirtualGL/TurboVNC session. The other GPUs will be setup with X servers, and information about them will be displayed. All GPUs are allocated with exclusive access.")
group.add_option("--specific-nodes", dest="specific_nodes", action="store_true", default=False, help="Use this if you want to allocate specific nodes. Use the -a option one or more times to specify the nodes you need. Note that only a matching  GPU on the first node will be used to power the VirtualGL/TurboVNC session. The other GPUs will be setup with X servers, and information about them will be displayed. All GPUs are allocated with exclusive access.")
parser.add_option_group(group)
group = OptionGroup(parser, "VirtualGL options")
group.add_option("-c", "--compress", dest="compress", action="store_true", default=False, help="Compress images using JPEG compression. By default, no compression is used. This option cannot be used with --x11-draw.")
group.add_option("--secure", dest="secure", action="store_true", default=False, help="By default the application's image stream is left unencrypted. This results in maximum performance. Using this option will encrypt the images using SSL, thereby reducing performance.  Enable this if you want absolute security. Also note that this option only takes effect if the allocated GPU is on a different node compared to where this script runs.")
group.add_option("--x11-draw", dest="x11_draw", action="store_true", default=False, help="Use this option if you are unable to use the VirtualGL client on your local X server. This will force VirtualGL to send uncompressed 3D images directly to your X server. Using this option will typically result in lower performance.")
parser.add_option_group(group)
group = OptionGroup(parser, "Miscellaneous options")
group.add_option("--shell", dest="start_shell", action="store_true", default=False, help="Use this option to start a shell after allocating a GPU. You may use the 'vglrun' command inside this shell to run one/more OpenGL applications.")
group.add_option("--show-gpu-types", dest="show_gpu_types", action="store_true", default=False, help="Prints out a list of GPU types that are potentially available for allocation")
parser.add_option_group(group)
(options, args) = parser.parse_args(sys.argv[1:])

# Extra arguments are errors.
if len(args)==0 and (options.show_gpu_types == False):
	if options.start_shell==False:
		print >>sys.stderr # empty line
		print >>sys.stderr, "Please specify a command to run"
		print >>sys.stderr # empty line
		parser.print_help()
		sys.exit(-1)

if (options.x11_draw == True) and (options.compress == True):
	print >>sys.stderr, "ERROR: The options --x11-draw and --compress are exclusive"
	sys.exit(-1)

# If stereo is asked for, then ask for an exclusive GPU automatically
if options.use_stereo:
	options.exclusive = True

# Check the DISPLAY environment variable
try:
	os.environ['DISPLAY']
except KeyError, e:
	print >>sys.stderr, "You must set the DISPLAY environment variable to your X display. This will be used to run your application with 'vglrun'"
	sys.exit(-1)

# Connect to the SSM
try:
	ra = ResourceAccess()
except VizError, e:
	print >>sys.stderr, "%s"%(str(e))
	sys.exit(-1)

# If we have a need to get the type of GPUs, then do so
if (options.show_gpu_types == True) or (options.gpu_type is not None):
	gpuList = ra.queryResources(vsapi.GPU())
	# Compute how many of which type are present
	gpuTypeInfo = {}
	for gpu in gpuList:
		gpuType = gpu.getType()
		try:
			gpuTypeInfo[gpuType] += 1
		except KeyError:
			gpuTypeInfo[gpuType] = 1

	if options.show_gpu_types == True:
		# If the user only asked us to print out GPU type information,
		# then we print it out
		for gpuType in gpuTypeInfo.keys():
			# FIXME: should I print out information about how many are free at this instant ?
			print "GPU type '%s', total available in system = %d"%(gpuType, gpuTypeInfo[gpuType])
		# Disconnect from the SSM
		ra.stop()
		# Exit with sucess
		sys.exit(0)

	if options.gpu_type is not None:
		if not gpuTypeInfo.has_key(options.gpu_type):
			print >>sys.stderr
			print >>sys.stderr, "Invalid GPU type '%s' passed on the command line.\nA valid value is one of %s.\nNote that you need to quote the string when running this script from the shell."%(options.gpu_type, gpuTypeInfo.keys())
			print >>sys.stderr
			sys.exit(-1)

# Validate the host list if user asked for specific hosts
# This helps us print messages that make more sense for the
# user
hostList = []
uniqHostList = []
indexList = []
if options.allocate_from is not None:
	# Get a list of all hostnames from the SSM
	nodeList = ra.queryResources(vsapi.VizNode())
	validHostList = []
	for node in nodeList:
		validHostList.append(node.getHostName())

	if options.specific_gpus:
		for host in options.allocate_from:
			parts = host.split("/")
			hostList.append(parts[0])
			indexList.append(int(parts[1]))
	else:
		hostList = options.allocate_from

	# Find out what's not valid
	invalidHostNames = filter(lambda x: x not in validHostList, hostList)

	# And print them out
	if len(invalidHostNames)>0:
		print >>sys.stderr
		print >>sys.stderr, "The following hostname(s) specified on the command line are invalid\n%s"%(invalidHostNames)
		print >>sys.stderr
		print >>sys.stderr, "Please ensure that they are indeed part of this system."
		print >>sys.stderr
		sys.exit(-1)
	
for name in hostList:
	if name not in uniqHostList:
		uniqHostList.append(name)

# Specific GPUs asked for are always exclusive
if options.specific_gpus:
	options.exclusive = True

# Specific nodes asked for are always FULL nodes
if options.specific_nodes:
	options.full_node = True

# Full node implies exclusive access	
if options.full_node:
	options.exclusive = True
	
# Allocate resources needed
try:
	# We'll need a GPU
	reqGPU = vsapi.GPU()
	if options.gpu_type is not None:
		reqGPU.setType(options.gpu_type)

	# Stereo needs a GPU with scanout and stereo caps
	if options.use_stereo == True:
		reqGPU.setUseScanOut(True)
		reqGPU.setAllowStereo(True)

	# Make a resource list with resources we need
	if options.exclusive:
		if not options.full_node:
			if options.specific_gpus:
				reqGPU.setHostName(hostList[0])
				reqGPU.setIndex(indexList[0])
			# Allocate am X server and a GPU
			reqList = [ [ reqGPU, vsapi.Server() ] ]
		else:
			nodeToAlloc = vsapi.VizNode()
			if options.specific_nodes:
				reqGPU.setHostName(hostList[0])
				
			nodeToAlloc.setResources([reqGPU, vsapi.Server()])
			reqList = [ nodeToAlloc ]
	else:
		# Allocate a shared GPU. X server will come from the GPU
		reqGPU.setShared(True)
		reqList = [ [ reqGPU ] ]

	# If more than one specific nodes or GPUs have been asked for, then do include them in the requirement as well.
	if options.specific_gpus:
		for i in range(1, len(hostList)):
			useGPU = copy.deepcopy(reqGPU)
			useGPU.setHostName(hostList[i])
			useGPU.setIndex(indexList[i])
			subReq = [ useGPU, Server() ]
			reqList.append(subReq)
	elif options.specific_nodes:
		for i in range(1, len(hostList)):
			useNode = vsapi.VizNode(hostList[i])
			reqList.append(useNode)

	# Allocate needed resources
	#pprint(reqList)
	alloc = ra.allocate(
		  reqList
		,
		uniqHostList
	)
except vsapi.VizError, e:
	print >>sys.stderr, "Unable to allocate resources needed for a rendering using VirtualGL."
	print >>sys.stderr, "Reason: %s"%(str(e))
	print >>sys.stderr
	print >>sys.stderr, "Please try again later"
	sys.exit(-1)

# Get the allocated resources
allocRes = alloc.getResources()
#pprint(allocRes)
extraSetupList = []

if not options.full_node:
	gpu = allocRes[0][0]
	if options.exclusive:
		xServer = allocRes[0][1]
	else:
		xServer = gpu.getSharedServer()
else:
	allocNode = allocRes[0]
	# We've allocated a whole node; so pick resources from there
	# We are guaranteed to have these !
	allNodeServers = vsapi.findMatchingObjects(vsapi.Server, vsapi.Server(), allocNode)
	allNodeGPUs = vsapi.findMatchingObjects(vsapi.GPU, vsapi.GPU(), allocNode)
	for idx in range(1,len(allNodeGPUs)):
		extraSetupList.append([allNodeGPUs[idx], allNodeServers[idx]])

	gpu = allNodeGPUs[0]
	xServer = allNodeServers[0]

print 'Using GPU %s/%d via %s%s for VirtualGL rendering'%(gpu.getHostName(), gpu.getIndex(), xServer.getHostName(), xServer.getDISPLAY())

# Setup the X server
scr = Screen(0)
# If enabled, then the GPU also needs to be configured for stereo
# We configure a 110 Hz active CRT stereo display.
# FIXME: If the stereo display is attached, then the display signals
# generated might activate the display. Since this is TurboVNC, there
# is no security related problem unless someone draws on the frame buffer
#
# We could eliminate this by creating a phony DVI device which
# runs active stereo at some refresh rate which no DVI device will use!?
#
if options.use_stereo == True:
	gpu.setScanout(port_index=0, display_device="Generic Stereo CRT", mode="1280x1024_110")
	scr.setFBProperty('stereo', 'active')
else:
	if gpu.getAllowNoScanOut():
		# VirtualGL uses a pbuffer anyway, so we choose a small resolution
		# virtual framebuffer
		gpu.clearScanouts()
		scr.setFBProperty('resolution',[640,480])
	else:
		# Configure a dummy display if no display is connected
		# already. Needed for GeForce GPUs to work.
		if len(gpu.getScanouts())==0:
			sc = gpu.getScanoutCaps()
			gpu.setScanout(0, 'HP LP2065', sc[0][0])
scr.setGPU(gpu)
xServer.addScreen(scr)

# Setup the other X servers (allocated due to specific-gpus & specific-nodes)
if options.specific_gpus:
	for allocPair in allocRes[1:]:
		extraSetupList.append(allocPair)
elif options.specific_nodes:
	for thisNode in allocRes[1:]:
		nodeServers = vsapi.findMatchingObjects(vsapi.Server, vsapi.Server(), thisNode)
		nodeGPUs = vsapi.findMatchingObjects(vsapi.GPU, vsapi.GPU(), thisNode)
		for idx in range(len(nodeGPUs)):
			extraSetupList.append([nodeGPUs[idx], nodeServers[idx]])

if len(extraSetupList)>0:
	for thisPair in extraSetupList:
		thisGPU = thisPair[0]
		thisServer = thisPair[1]

		thisScr = Screen(0)
		if options.use_stereo == True:
			thisGPU.setScanout(port_index=0, display_device="Generic Stereo CRT", mode="1280x1024_110")
			thisScr.setFBProperty('stereo', 'active')
		else:
			if thisGPU.getAllowNoScanOut():
				# VirtualGL uses a pbuffer anyway, so we choose a small resolution
				# virtual framebuffer
				thisGPU.clearScanouts()
				thisScr.setFBProperty('resolution',[640,480])
			else:
				# Configure a dummy display if no display is connected
				# already. Needed for GeForce GPUs to work.
				if len(gpu.getScanouts())==0:
					sc = thisGPU.getScanoutCaps()
					thisGPU.setScanout(0, 'HP LP2065', sc[0][0])
		thisScr.setGPU(thisGPU)
		thisServer.addScreen(thisScr)
	print 'NOTE: Configured %d additional GPUs for rendering, but these are not being used this script.\nThese GPUs are :'%(len(extraSetupList))
	for thisPair in extraSetupList:
		thisGPU = thisPair[0]
		thisServer = thisPair[1]
		print '  GPU %s/%d accessible using X server %s%s'%(thisGPU.getHostName(), thisGPU.getIndex(), thisServer.getHostName(), thisServer.getDISPLAY())
	print
	

# Propagate the X server settings to the SSM
alloc.setupViz(ra)

# Start the X server
alloc.startViz(ra)

vglNode = xServer.getHostName()

vglRunEnv = []
# Use the VGL client if not using direct X11 drawing
if not options.x11_draw:
	try:
		vglClientHost = os.environ['VGL_CLIENT']
	except:
		vglClientHost = None

		# Try deriving VGL client location from the SSH environment
		if os.environ.has_key('SSH_CLIENT'):
			# SSH_CLIENT environment variable will be of the
			# form "IP src_port dst_port"
			# e.g. "16.181.65.30 1845 22"
			sshClient = os.environ['SSH_CLIENT'].split(' ')[0]
			vglClientHost = sshClient

	if vglClientHost is not None:
		try:
			vglClientPort = int(os.environ['VGL_PORT'])
		except:
			# assume default client port
			vglClientPort = 4242

	if not vglClientHost:

		# We use the vglclient if the allocated GPU is on the same
		# node as us. Why ?
		#
		# I have observed that using x11_draw is slower than using
		# the vglclient for rendering. A possible reason for this is
		# that the vglclient uses faster pixel drawing methods - e.g.
		# OpenGL.

		# Start the VGL client on the local machine
		# The VGL client will print the port number where the VGL client is listening
		# If a VGL client is already running on the local machine, then it will 
		# print out the port number of the running client and exit
		#
		# One potential issue with this approach is that the vglclient program keeps
		# running even when the script exits. We allow this behaviour to remain. If
		# we killed the vglclient, then two or more instances of this script can't
		# run at the same time.
		#
		# A vglclient instance is associated with an X server, so this is not a problem
		# with multiple vglclients running on different X servers, potentially for one/more
		# users.
		#

		vglClientProc = subprocess.Popen(['/opt/VirtualGL/bin/vglclient', '-detach'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
		outMsg, errMsg = vglClientProc.communicate()
		vglClientProc.wait()

		vglClientHost = xServer.getHostName()
		try:
			vglClientPort = int(outMsg.lstrip().rstrip())
			print 'VirtualGL client running on host %s, port %d'%(vglClientHost, vglClientPort)
		except:
			# The vglclient segfaulted on Ubuntu, so I put in this.
			# FIXME: quad buffered stereo rendering will fail there is no client. Should
			# we terminate app in this case?
			print 'Failed to start VGL client'
			vglClientHost = vglClientPort = None
	else:
		print 'VirtualGL client assumed to be running on host %s port %d'%(vglClientHost, vglClientPort)

	if vglClientHost is not None:
		# Contribute to environment setup
		vglRunEnv = ["VGL_CLIENT=%s"%(vglClientHost), "VGL_PORT=%s"%(vglClientPort)]

if vglNode not in [ "localhost", socket.gethostname()]:
	# Use SSH 
	# -t gives a nicer shell on distros that use a color scheme - e.g. SLES
	cmdArgs = ["ssh", "-t", "-X", xServer.getHostName()]
	otherMachine = True

	# If security is asked for, enable SSL with VGL
	if options.secure == True:
		vglRunEnv += ["VGL_SSL=1"]
else:
	cmdArgs = []
	otherMachine = False

vglRunEnv += ["VGL_DISPLAY=%s"%(xServer.getDISPLAY())]

# Enable stereo if asked for
if options.use_stereo == True:
	vglRunEnv += ["VGL_STEREO=quad"]

if options.x11_draw == True:
	# Use proxy drawing if explicitly asked for
	# FIXME: should we fail usage of stereo with this ?
	# vglrun autonatically uses anaglyphic stereo if
	# the virtualgl client is not used
	vglRunEnv += ["VGL_COMPRESS=proxy"]
elif (otherMachine == True) and (vglClientHost is not None):
	# Use the VGL image transport only if we know that the
	# client is running
	if options.compress == True:
		vglRunEnv += ["VGL_COMPRESS=jpeg"]
	else:
		vglRunEnv += ["VGL_COMPRESS=rgb"]

# Propagare the DISPLAY variable, unless we are going to
# execute on another machine.
# FIXME: Is this really necessary to propagate DISPLAY
# explicitly ?
if os.environ.has_key('DISPLAY') and (not otherMachine):
	vglRunEnv += ["DISPLAY=%s"%(os.environ["DISPLAY"])]

# Start a shell or use vglrun as appropriate
if options.start_shell == True:
	#args = ["/bin/bash"]
	# Get the shell preferred by the user from the password database
	# Index 6 corresponds to the command interpreter 
	# see http://docs.python.org/library/pwd.html
	args = [ pwd.getpwuid(os.getuid())[6] ]
	if otherMachine:
		# Start an interactive shell
		# NOTE: I have checked that bash, ksh, tcsh and zsh interpret
		# the "-i" option the same way - i.e. they all start an interactive shell
		args += ["-i"] # -i for interactive shell
	print "Allocated GPU %d controlled by X Server '%s' on host '%s' for you."%(gpu.getIndex(), xServer.getDISPLAY(), xServer.getHostName())
	if (vglNode != "localhost") and (vglNode != socket.gethostname()):
		print "Starting secure shell to host '%s'..."%(xServer.getHostName())
	else:
		print "Starting shell..."
	print
	print "When you exit this shell, the GPU will be freed for use by others."
	print "Inside this shell, please use \"vglrun\" to run your OpenGL application."
	print
	shellArgs = []
else:
	args = ["/usr/bin/vglrun"]+args
	shellArgs = ["/opt/vizstack/bin/vs-aew"]
	print "Running application '%s' on host '%s', gpu %d, server %s"%(string.join(args," "), xServer.getHostName(), gpu.getIndex(), xServer.getDISPLAY())

# Run the command needed
overallCmd = cmdArgs + shellArgs + [ "/usr/bin/env" ] + vglRunEnv + args

os.system(string.join(overallCmd," "))

if options.start_shell == True:
	print "Cleaning up..."

# Stop the real X server - this is not needed actually
alloc.stopViz(ra)

# Deallocate resources. We do this quickly to prevent GDM from keeping running!
ra.deallocate(alloc)

# Disconnect from the SSM - we're done!
ra.stop()
