#!/usr/bin/env python
# VizStack - A Framework to manage visualization resources

# Copyright (C) 2009-2010 Hewlett-Packard
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""
viz-equalizer

Script to help run equalizer applications. The equalizer
server can be setup in a varierty of ways
 - driving a display wall, with a local operator window
 - DB (sort-last) or 2D (sort-first) decomposition using
   N GPUs.

Here's the approximate sequence:
  1. Allocates resources, starts X servers
  2. Generates equalizer server config file.
  3. Starts the following components
     - equalizer render clients on each allocated GPU
     - equalizer server on the node where you run this script
     - equalizer 'master app' on the node where you run this script
     - equalizer server on the node where you run this script
  4. Waits for app to exit
  5. Kills server (else it would wait!). Render clients exit after
     a single render anyway.
  6. Cleanup & exit

Usage examples :

$ viz-equalizer -n 3 eqHello

will run the eqHello program using 3 additional GPUs. Note that eqHello is 
also the default program.

$ viz-equalizer -n 2 -- eVolve -m ~/equalizer-release-0.9.1/examples/eVolve/Bucky32x32x32_d.raw

will run the eVolve volume rendering application using 2 additional GPUs.
The Bucky dataset supplied with equalizer will be used.

$ viz-equalizer -r 2 -- eqPly -m ~/equalizer-release-0.9.1/examples/eqPly/screwdriver.ply

Will render the screwdriver model supplied with Equalizer using 2 additional GPUs.

$ viz-equalizer -t 4x4 -- eqPly -m ~/happy.ply

Will render a Happy Buddha ply model in the user's home directory. The
complete image will be rendered on the tiled display named '4x4', and a
rescaled copy will be shown on your local GUI.
"""

import vsapi
from pprint import pprint
import sys
import os
import subprocess
from pprint import pprint
from optparse import OptionParser
import string
import tempfile
import time
import operator
import signal

def generateConfigWall(runningUnderVGL, showMonitor, fastNetworkMap, td, configFile):
	"""
	Create an equalizer server config file that uses 2D
	compound
	"""
	td = rg.getHandlerObject()
	#
	#
	# XXX: FIXME: the showMonitor code causes BAD BAD performance if 
	# run inside a VGL session.  
	#
	layoutMatrix = td.getLayoutMatrix()
	hostScreens = {}
	for row in range(len(layoutMatrix)):
		for col in range(len(layoutMatrix[0])):
			#print layoutMatrix[row][col]['gl_area']
			bl = layoutMatrix[row][col]
			scr = bl['screen']
			srv = bl['server']
			try:
				hostScreens[srv.getHostName()].append(bl)
			except:
				hostScreens[srv.getHostName()] = [ bl ]

	eqServerHost = None 

	if 'localhost' in hostScreens:
		eqServerHost = 'localhost'
	else:
		eqServerHost = socket.gethostname()

	# Compute the base port by looking up our DISPLAY value
	# FIXME: This will not allow multiple servers to run
	basePort = 4000
	clientBasePort = basePort + 20
	try:
		display =  os.environ['DISPLAY']
		eqServerPort = basePort + int(display.split(':')[1].split('.')[0])
	except:
		eqServerPort = basePort 

	print >>configFile, "#Equalizer 1.0 ascii"

	print >>configFile, "#"
	print >>configFile, "# Configuration file generated by VizStack"
	print >>configFile, "# Sort-first (2D) on tiled display"
	print >>configFile, "#"
	print >>configFile, "server"
	print >>configFile, "{"
	print >>configFile, "    connection"
	print >>configFile, "    {"
	print >>configFile, "        type TCPIP"
	print >>configFile, "        port %d"%(eqServerPort)
	print >>configFile, "    }"
	print >>configFile, "    config"
	print >>configFile, "    {"

	if (showMonitor is True) or (hostScreens.has_key(eqServerHost)):
		print >>configFile, "        appNode"
		print >>configFile, "        {"

	if showMonitor is True:
		print >>configFile, "            pipe"
		print >>configFile, "            {"
		print >>configFile, "                window"
		print >>configFile, "                {"
		print >>configFile, '                  name "Rescaled Tiled Display %s"'%(rg.getName())
		print >>configFile, "                  viewport [ 0.25 0.7 0.5 0.25 ]"
		print >>configFile, '                  channel { name "operator" }'
		print >>configFile, "                }"
		print >>configFile, "            }"

	gl_areas = []
	channelIndex = 0
	ignoreEqServerHost = False
	if hostScreens.has_key(eqServerHost) and not runningUnderVGL:
		ignoreEqServerHost = True
		for bl in hostScreens[eqServerHost]:
			scr = bl['screen']
			print >>configFile, "            # The pipe below points to DISPLAY=%s. A window is created here for rendering."%(scr.getDISPLAY())
			print >>configFile, "            pipe"
			print >>configFile, "            {"
			print >>configFile, "                port %d"%(scr.getServer().getIndex())
			print >>configFile, "                device %d"%(scr.getScreenNumber())
			print >>configFile, "                window"
			print >>configFile, "                {"
			print >>configFile, "                    attributes { hint_drawable window planes_color RGBA8 planes_depth ON  }"
			print >>configFile, '                    channel { name "channel%d" }'%(channelIndex)
			print >>configFile, "                }"
			print >>configFile, "            }"
			channelIndex += 1
			gl_areas.append(bl['gl_area'])

	if (showMonitor is True) or (hostScreens.has_key(eqServerHost)):
		print >>configFile, "        }"

	eqAppCmdSuffix = ['--eq-server', '%s:%d'%(fastNetworkMap[eqServerHost], eqServerPort)]

	eqRenderClients = []
	for hostName in hostScreens:
		if (hostName == eqServerHost) and ignoreEqServerHost:
			continue

		# Compute a port number using the GPU
		nodePort = clientBasePort
		for bl in hostScreens[hostName]:
			scr = bl['screen']
			for gpu in scr.getGPUs():
				nodePort += (1<<gpu.getIndex())

		print >>configFile, "        node"
		print >>configFile, "        {"
		print >>configFile, '            connection'
		print >>configFile, '            {'
		print >>configFile, '                hostname "%s" type TCPIP port %d '%(fastNetworkMap[hostName], nodePort)
		print >>configFile, '            }'

		eqRenderClients.append({
			'cmdSuffix':['--eq-client', '--eq-listen', '%s:%d'%(fastNetworkMap[hostName], nodePort)],
			'runner': hostScreens[hostName][0]['screen'].getSchedulable() })

		for bl in hostScreens[hostName]:
			scr = bl['screen']
			print >>configFile, "            # The pipe below points to DISPLAY=%s. This is one of the 'blocks' of the tiled display"%(scr.getDISPLAY())
			print >>configFile, "            pipe"
			print >>configFile, "            {"
			print >>configFile, "                port %d"%(srv.getIndex())
			print >>configFile, "                device %d"%(scr.getScreenNumber())
			print >>configFile, "                window"
			print >>configFile, "                {"
			print >>configFile, "                    viewport [ 0 0 1 1 ]"
			print >>configFile, "                    attributes { hint_drawable window planes_color RGBA8 planes_depth ON }"
			print >>configFile, '                    channel { name "channel%d" }'%(channelIndex)
			print >>configFile, "                }"
			print >>configFile, "            }"
			channelIndex += 1
			gl_areas.append(bl['gl_area'])
		print >>configFile, "        }"

	# FIXME: determine these from tiled display!
	wall_min_x = -0.8
	wall_max_x = 0.8
	wall_min_y = -0.5
	wall_max_y = 0.5
	wall_depth = -1

	wall_width = wall_max_x - wall_min_x
	wall_height = wall_max_y - wall_min_y

	if showMonitor:
		print >>configFile, "        layout"
		print >>configFile, "        {"
		print >>configFile, '            name "operator_layout"'
		print >>configFile, '            view {}'
		print >>configFile, '        }'
	
	print >>configFile, "        layout"
	print >>configFile, "        {"
	print >>configFile, '            name "mylayout"'
	for idx in range(len(gl_areas)):
		print >>configFile, '            view'
		print >>configFile, '            {'
		fwidth = gl_areas[idx][2]-gl_areas[idx][0]
		fheight = gl_areas[idx][3]-gl_areas[idx][1]
		x = gl_areas[idx][0]
		y = gl_areas[idx][1]
		print >>configFile, '                viewport [ %f %f %f %f ]'%(gl_areas[idx][0], gl_areas[idx][1], fwidth, fheight)
		print >>configFile, '                wall'
		print >>configFile, '                {'
		print >>configFile, '                    bottom_left [ %f %f %f ]'%(wall_min_x+(x*wall_width), wall_min_y+(y*wall_height), wall_depth)
		print >>configFile, '                    bottom_right [ %f %f %f ]'%(wall_min_x+((x+fwidth)*wall_width), wall_min_y+(y*wall_height), wall_depth)
		print >>configFile, '                    top_left [ %f %f %f ]'%(wall_min_x+(x*wall_width), wall_min_y+((y+fheight)*wall_height), wall_depth)
		print >>configFile, '                }'
		print >>configFile, '            }'
	print >>configFile, "        }"

	print >>configFile, "        canvas"
	print >>configFile, "        {"
	print >>configFile, '            layout "mylayout"'
	if showMonitor:
		print >>configFile, '            layout "operator_layout"'
	print >>configFile, '            wall'
	print >>configFile, '            {'
	print >>configFile, '                bottom_left [ %f %f %f ]'%(wall_min_x, wall_min_y, wall_depth)
	print >>configFile, '                bottom_right [ %f %f %f ]'%(wall_max_x, wall_min_y, wall_depth)
	print >>configFile, '                top_left [ %f %f %f ]'%(wall_min_x, wall_max_y, wall_depth)
	print >>configFile, '            }'
	for idx in range(len(gl_areas)):
		print >>configFile, '            segment { channel "channel%d" viewport [ %f %f %f %f ] }'%(idx, gl_areas[idx][0], gl_areas[idx][1], gl_areas[idx][2]-gl_areas[idx][0], gl_areas[idx][3]-gl_areas[idx][1])
	print >>configFile, "        }"

	if showMonitor:
		print >>configFile, "        canvas"
		print >>configFile, "        {"
		print >>configFile, '            layout "operator_layout"'
		print >>configFile, '            wall'
		print >>configFile, '            {'
		print >>configFile, '                bottom_left [ %f %f %f ]'%(wall_min_x, wall_min_y, wall_depth)
		print >>configFile, '                bottom_right [ %f %f %f ]'%(wall_max_x, wall_min_y, wall_depth)
		print >>configFile, '                top_left [ %f %f %f ]'%(wall_min_x, wall_max_y, wall_depth)
		print >>configFile, '            }'
		print >>configFile, '            segment { channel "operator" }'
		print >>configFile, "        }"
		
	print >>configFile, "    }"
	print >>configFile, "}"

	configFile.flush()

	#os.system("cat %s"%(configFile.name))
	return [eqAppCmdSuffix, eqRenderClients]

def generateConfigNGPU(runningUnderVGL, renderMode, use_load_equalizer, fastNetworkMap, allServers, configFile):
	"""
	Create an equalizer server config file that uses the DB (sort last)
	compound.
	"""
	hostServers = {}
	for srv in allServers:
		try:
			hostServers[srv.getHostName()].append(srv)
		except:
			hostServers[srv.getHostName()] = [ srv ]

	eqServerHost = None

	print >>configFile, "#Equalizer 1.0 ascii"

	numGPUs = 0
	for srvHost in hostServers:
		for srv in hostServers[srvHost]:
			for scr in srv.getScreens():
				numGPUs += 1

	if 'localhost' in hostServers:
		eqServerHost = 'localhost'
	else:
		eqServerHost = socket.gethostname()

	# Compute the base port by looking up our DISPLAY value
	# FIXME: This will not allow multiple servers to run
	basePort = 4000
	clientBasePort = basePort + 20
	try:
		display =  os.environ['DISPLAY']
		eqServerPort = basePort + int(display.split(':')[1].split('.')[0])
	except:
		eqServerPort = basePort 

	print >>configFile, "#"
	print >>configFile, "# Configuration file generated by VizStack"
	print >>configFile, "# DB (Sort-last) compound using %d GPUs"%(numGPUs)
	print >>configFile, "#"
	print >>configFile, "server"
	print >>configFile, "{"
	print >>configFile, "    connection"
	print >>configFile, "    {"
	print >>configFile, "        type TCPIP"
	print >>configFile, "        port %d"%(eqServerPort)
	print >>configFile, "    }"
	print >>configFile, "    config"
	print >>configFile, "    {"
	print >>configFile, "        # One AppNode to include local rendering plus any GPU(s) allocated on the same node"
	print >>configFile, "        appNode"
	print >>configFile, "        {"
	print >>configFile, "            # The pipe below points to DISPLAY=%s. This is where the app shows its GUI"%(display)
	print >>configFile, "            pipe"
	print >>configFile, "            {"
	print >>configFile, "                window"
	print >>configFile, "                {"
	print >>configFile, "                    viewport [ 100 100 640 480 ] "
	print >>configFile, "                    attributes { hint_fullscreen OFF }"
	print >>configFile, "                    attributes { planes_stencil ON }"
	print >>configFile, '                    channel { name "master" }'
	print >>configFile, "                }"
	print >>configFile, "            }"

	channelIndex = 0
	ignoreEqServerHost = False
	if hostServers.has_key(eqServerHost) and not runningUnderVGL:
		for srv in hostServers[eqServerHost]:
			for scr in srv.getScreens():
				print >>configFile, "            # The pipe below points to DISPLAY=%s. A PBO is created here for rendering."%(scr.getDISPLAY())
				print >>configFile, "            pipe"
				print >>configFile, "            {"
				print >>configFile, "                port %d"%(srv.getIndex())
				print >>configFile, "                device %d"%(scr.getScreenNumber())
				print >>configFile, "                window"
				print >>configFile, "                {"
				print >>configFile, "                    attributes { hint_drawable FBO planes_color RGBA8 planes_depth ON }"
				print >>configFile, '                    channel { name "channel%d" }'%(channelIndex)
				print >>configFile, "                }"
				print >>configFile, "            }"
				channelIndex += 1
		ignoreEqServerHost = True

	print >>configFile, "        }"

	eqAppCmdSuffix = ['--eq-server', '%s:%d'%(fastNetworkMap[eqServerHost], eqServerPort)]

	eqRenderClients = []
	for hostName in hostServers:
		if (hostName == eqServerHost) and (ignoreEqServerHost):
			continue

		# Compute a port number using the GPU
		nodePort = clientBasePort
		for srv in hostServers[hostName]:
			for scr in srv.getScreens():
				for gpu in scr.getGPUs():
					nodePort += (1<<gpu.getIndex())

		eqRenderClients.append({
			'cmdSuffix':['--eq-client', '--eq-listen', '%s:%d'%(fastNetworkMap[hostName], nodePort)],
			'runner': scr.getSchedulable() })
		print >>configFile, "        node"
		print >>configFile, "        {"
		print >>configFile, '            connection'
		print >>configFile, '            {'
		print >>configFile, '                hostname "%s" type TCPIP port %d '%(fastNetworkMap[hostName], nodePort)
		print >>configFile, '            }'

		for srv in hostServers[hostName]:
			for scr in srv.getScreens():
				print >>configFile, "            # The pipe below points to DISPLAY=%s. A PBO is created here for rendering."%(scr.getDISPLAY())
				print >>configFile, "            pipe"
				print >>configFile, "            {"
				print >>configFile, "                port %d"%(srv.getIndex())
				print >>configFile, "                device %d"%(scr.getScreenNumber())
				print >>configFile, "                window"
				print >>configFile, "                {"
				print >>configFile, "                    attributes { hint_drawable FBO planes_color RGBA8 planes_depth ON }"
				print >>configFile, '                    channel { name "channel%d" }'%(channelIndex)
				print >>configFile, "                }"
				print >>configFile, "            }"
				channelIndex += 1

		print >>configFile, "        }"

	gpuFactor = 1.0/(numGPUs+1)

	print >>configFile, "        compound"
	print >>configFile, "        {"
	print >>configFile, '            channel "master"'

	if renderMode=='DB':
		print >>configFile, '            buffer [ COLOR DEPTH ]'
		if use_load_equalizer:
			print >>configFile, '            load_equalizer { mode DB }'
	elif renderMode=='2D':
		if use_load_equalizer:
			print >>configFile, '            load_equalizer { mode 2D }'
	else: # DPlex
		print >>configFile, '        framerate_equalizer {}'

	print >>configFile, '            wall'
	print >>configFile, '            {'
	print >>configFile, '                bottom_left [ -.8 -.5 -1 ]'
	print >>configFile, '                bottom_right [ .8 -.5 -1 ]'
	print >>configFile, '                top_left [ -.8 .5 -1 ]'
	print >>configFile, '            }'
	print >>configFile, '            compound'
	print >>configFile, '            {'
	if (renderMode == 'DB') and (not use_load_equalizer):
		print >>configFile, '                range [ 0 %f ]'%(gpuFactor)
	elif renderMode == '2D':
		print >>configFile, '                viewport [ 0 0 %f 1 ]'%(gpuFactor) # divide by width segs
	else: # Dplex
		print >>configFile, '                channel "master"'
		print >>configFile, '                phase 0'
		print >>configFile, '                period %d'%(numGPUs+1)
		print >>configFile, '                outputframe { name "frame.DPlex" }'
	print >>configFile, '            }'
	for channelIndex in range(numGPUs):
		print >>configFile, '            compound'
		print >>configFile, '            {'
		print >>configFile, '                channel "channel%d"'%(channelIndex)
		if renderMode == 'DB':
			print >>configFile, '                range [ %f %f ]'%(gpuFactor*(channelIndex+1), gpuFactor*(channelIndex+2))
			print >>configFile, '                outputframe {}'
		elif renderMode=='2D':
			print >>configFile, '                viewport [ %f 0 %f 1 ]'%(gpuFactor*(channelIndex+1), gpuFactor)
			print >>configFile, '                outputframe {}'
		else:
			print >>configFile, '                phase %d'%(channelIndex+1)
			print >>configFile, '                period %d'%(numGPUs+1)
			print >>configFile, '                outputframe { name "frame.DPlex" }'
		print >>configFile, '            }'
	if renderMode in ['DB','2D']:
		for channelIndex in range(numGPUs):
			print >>configFile, '            inputframe { name "frame.channel%d" }'%(channelIndex)
	else:
		print >>configFile, '            inputframe { name "frame.DPlex" }'
	print >>configFile, "        }"
	print >>configFile, "    }"
	print >>configFile, "}"

	configFile.flush()
	#os.system('cat %s'%(configFile.name))
	return [eqAppCmdSuffix, eqRenderClients]

#
# Script execution starts here
#

# Setup the command line parser
parser = OptionParser(
usage="usage: %prog <-r num_gpus> [application] [application params]",
description="""
Runs an equalizer application on the VizStack system.
The equalizer server is setup to do database decomposition.
Results are displayed on the node where this script runs.
"""
)
parser.add_option("-r", "--num-gpus", action="store", type="int", dest="num_gpus", help="Use these many GPUs for scalable rendering.")
parser.add_option("--sort-last", action="store_true", dest="sort_last", default=False,help="Use sort-first (2D compound) for scalable rendering; use with -r.")
parser.add_option("--sort-first", action="store_true", dest="sort_first", default=False,help="Use sort-last (DB compound) for scalable rendering; use with -r.")
parser.add_option("--dplex", action="store_true", dest="dplex", default=False,help="Use the DPlex compound to alternate frame rendering; use with -r.")
parser.add_option("--load-equalizer", action="store_true", dest="load_equalizer", default=False,help="Use Equalizer's load equalization supporti; use with -r. If you use sort last, then the DB mode is used. If you are using sort first, then 2D mode is used. This option is not effective with --dplex")
parser.add_option("-t", "--tiled-display", action="store", type="string", dest="tiled_display", help="Run on a tiled display wall")
parser.add_option("--no-control-gui", action="store_false", dest="show_control_gui", default=True,help="Do not show a control GUI. Normally, a rescaled copy of the tiled display wall is shown on the local display; effective with -t")

# Parse & validate arguments
(options, args) = parser.parse_args(sys.argv[1:])
if not operator.xor(options.num_gpus is None, options.tiled_display is None):
	print >>sys.stderr, "You need to use one of -t or -r"
	parser.print_help()
	sys.exit(-1)

if options.num_gpus is not None and (options.num_gpus <= 0):
	print >>sys.stderr, "Please specify one or more GPUs"
	parser.print_help()
	sys.exit(-1)

if options.num_gpus is not None:
	if (int(options.sort_first)+int(options.sort_last)+int(options.dplex))>1:
		print >>sys.stderr, "You may use only one of --sort-first, --sort-last or --dplex"
		sys.exit(-1)
	if (options.sort_first or options.sort_last or options.dplex)==False:
		print "You haven't specified a rendering mode; defaulting to sort-last"
		options.sort_last = True

	if options.sort_last:
		renderMode = 'DB'
	elif options.sort_first:
		renderMode = '2D'
	else:
		renderMode = 'DPlex'
if len(args)==0:
	inputCmd = ["eqHello"]
	print "No command specified. I'll run eqHello for you!"
else:
	inputCmd = args

# Create a temporary config file
try:
	configFile = tempfile.NamedTemporaryFile()
except IOError, e:
	print >> sys.stderr, e.str()
	sys.exit(1)

# Connect to the SSM
ra = vsapi.ResourceAccess()

# Create a mapping from the hostname to the fast network
# we'll refer to the hostnames in the fast network
allNodes = ra.queryResources(vsapi.VizNode())
fastNetworkMap = {}
for thisNode in allNodes:
    fastNetworkMap[thisNode.getHostName()] = thisNode.getProperty('fast_network')

if os.environ.has_key('VGL_DISPLAY'):
	runningUnderVGL = True
else:
	runningUnderVGL = False

print "Allocating resources..."
if options.num_gpus is not None:
	single_gpu_spec = [ vsapi.GPU(), vsapi.Server() ] 
	# Allocate the <n> pairs of GPUs and X servers
	alloc = ra.allocate(
		[single_gpu_spec] * options.num_gpus
	)
	resources = alloc.getResources()
	#print "Allocated Resources are:"
	#pprint(resources)
	#print

	# Configure each X server to provide one Screen(Framebuffer)
	# on a GPU. The X server's maximum resolution needs to be 
	# fixed at the max size of the client window.
	#
	maxRes = [1600, 1200]
	allServers = []
	for res in resources: # iterate through each GPU, Server combination.
		gpu = res[0]
		srv = res[1]
		scr = vsapi.Screen(0)
		if gpu.getAllowNoScanOut():
			# Configure a virtual framebuffer if possible
			gpu.clearScanouts()
			scr.setFBProperty('resolution', maxRes)
		else:
			# Configure a dummy display if no display is connected
			# already. Needed for GeForce GPUs to work.
			if len(gpu.getScanouts())==0:
				sc = gpu.getScanoutCaps()
				gpu.setScanout(0, 'HP LP2065', sc[0][0])
		scr.setGPU(gpu)
		srv.addScreen(scr)
		allServers.append(srv)

	# Create the configuration file needed for the server
	eqAppCmdSuffix, eqRenderClients = generateConfigNGPU(runningUnderVGL, renderMode, options.load_equalizer, fastNetworkMap, allServers, configFile)

elif options.tiled_display is not None:
	alloc = ra.allocate( [vsapi.ResourceGroup(options.tiled_display) ] )
	rg = alloc.getResources()[0]
	eqAppCmdSuffix, eqRenderClients = generateConfigWall(runningUnderVGL, options.show_control_gui, fastNetworkMap, rg, configFile)
#
# NOTE: it is possible that we will get more than one
# GPU on the same node. In this case, we could consider
# controlling each GPU as one screen of an X server.
# Naturally, only one X server would get used per node,
# and the rest would lie unused. This is left as an
# exercise for the reader !
#

# Propagate X server configuration to the SSM
alloc.setupViz(ra)

# Starts all the X servers
print "Starting X servers..."
alloc.startViz(ra)

# Create a modified environment for the 
# non-virtualGL processes to run. Currently, this ensures that
# VirtualGL's librrfaker.so LD_PRELOAD does not affect
# these
safeEnv = vsapi.sanitisedEnv()

# Run one equalizer render client program on each GPU
print "Starting Render Clients..."
clients = []
for erc in eqRenderClients:
	thisCmd = inputCmd + ['--'] + erc['cmdSuffix']
	print 'Running render client :'
	print thisCmd
	clients.append(erc['runner'].run(thisCmd))

# Server always runs on the execution host
print 'Starting Equalizer Server...'
serverCmd = ["/opt/vizstack/bin/vs-aew", "eqServer", configFile.name]
print serverCmd
serverProc = subprocess.Popen(serverCmd)
# wait for a few secs for the server to come up - else the app will exit and the script will fail
print 'Sleep to let server and render clients to come up!'
time.sleep(10)

appCmd = inputCmd+ ['--'] + eqAppCmdSuffix
print "Starting Application"
print appCmd
if os.environ.has_key('VGL_DISPLAY'):
	appCmd = ["/usr/bin/vglrun"]+appCmd
appCmd = ["/opt/vizstack/bin/vs-aew"] + appCmd
appProc = subprocess.Popen(appCmd)
localGUI = (options.tiled_display is None) or (options.show_control_gui)
if not localGUI:
	try:
		print 'Application is running on tiled display. Press ^C to exit...'
		while True:
			time.sleep(1)
	except KeyboardInterrupt:
		print 'Killing App...'
		appProc.terminate()
appProc.wait()

# Kill the server once the app exits
print 'Killing eqServer...'

def terminateProcess(p):
	try:
		p.terminate() # Python 2.6 and above
	except AttributeError: # older versions!
		os.kill(p.pid, signal.SIGTERM)
		p.wait()

terminateProcess(serverProc)

# Terminate client programs if they are still running
print 'Killing clients...'
for proc in clients:
	proc.kill()

print "Cleaning up. Please wait..."
# Kill all the X servers
alloc.stopViz(ra)

# Give up all the resources
ra.deallocate(alloc)

# Done!
ra.stop()
